# My-university-code
数据结构代码
这是一个codeblock上的一个代码文件：
一个循环队列代码，其中有一个bug是main()中的scanf函数执行后会导致Q的地址被改变目前还未找到问题所在

问题已解决：
1.https://blog.csdn.net/xiaxiaojing/article/details/125542326?app_version=6.1.8&code=app_1562916241&csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22125542326%22%2C%22source%22%3A%22planet9921%22%7D&uLinkId=usr1mkqgl919blen&utm_source=app
//这是说scanf函数导致的异常问题
2.https://blog.csdn.net/tjcwt2011/article/details/112799845?app_version=6.1.8&code=app_1562916241&csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22112799845%22%2C%22source%22%3A%22planet9921%22%7D&uLinkId=usr1mkqgl919blen&utm_source=app
//这个是对于scanf函数的总结

int scanf(char*,...)是其函数声明。其中只要求第一个参数是char*，即字符串即可，而对于其他参数则没有限制类型和个数，这其中有安全风险。举个例子：
scanf(“%d %c”,&i,&ch);如果从键盘上输入的数据是：30 A？则变量ch的值是空格字符而不是字符‘A’。这种错误很隐蔽，因此建议读者尽量不要使用scanf函数从键盘上输入包含字符数据在内的一组不同类型的数据值，以免发生莫名其妙的错误。另外下面的例子：

#include <cstdio>
int main()
{
    char a;
    while( scanf("%c",&a), a!='\n' )
        printf("%c", a);
    printf("\n");
    return 0;
}

可以看出，通过scanf函数可以接受任意的键盘的输入，如果输入的长度超过了应用给定的缓冲区，就会覆盖其他数据区，这称为“堆栈溢出”或“缓冲区溢出”。而且scanf函数有三个特点：
1. 取数据时遇到空格、回车、TAB就会停止；
2. scanf函数和都是从输入流缓冲区中读取数据的，而不是从键盘（终端）缓冲区读取值的。读取时遇到回车\n即结束，且回车\n会被读入输入缓冲数据流中，这样第二次的读入函数将输入缓冲区中的回车\n读取走了，没有等待键盘的二次输入。
3. scanf读取字符串时，会舍弃最后的回车符。
从第二个特点，我们可以看出在上例中，如果输入很长，最后以'\n'结束后，'\n'会覆盖后面的数据区，造成缓冲区溢出。

附：scanf函数小结：
1. scanf函数中一个重要的参数：%[ ]意思是读入一个字符集合，%[ ]特指读入此集合所限定的那些字符，比如%[A-Z]表示输入大写字符，一旦遇到不符合的，输入就停止，但是读入的字符串中可以包含空格。
2. scanf()函数的一般格式为：scanf("格式字符串"，输入项首地址表)
scanf的格式控制的一般形式为：%[*][宽度][F|N][h|l]类型字符

    []中的控制字符为可选项 
    "*"表示该输入项读入后不赋予任何变量，即跳过该输入值。这在减小内存开支上面还是有一点用处的，不需要的字符直接跳过，免得申请没用的变量空间 
    "宽度"表示输入读入字符的长度，对于整型表示截取相应宽度的数字赋给后面列表中的相应变量；对于字符型表示读入相应长度的字符后把第一个字符赋给相应的变量，其余的自动舍弃。例如scanf("%2d%3d",&a, &b);如果输入为12345则将12赋给a，将45赋给b；scanf("%2c%3c",&a, &b);如果输入为12345则将'1'赋给a，将'3'赋给b 
    F 、N、h、l分别表示远指针、近指针、短整和长整型，对于_int64相应的控制字符为ll或I64 
    "类型字符"为 d -- 输入十进制整数 、o -- 输入八进制整数 、x -- 输入十六进制整数 、u -- 输入无符号十进制整数 f或e -- 输入实型数(用小数形式或指数形式) 、c -- 输入单个字符 、s -- 输入字符串 

字符串读入的一些技巧
对于输入字符串还有一些比较有用的控制,
例如经常需要读入一行字符串，而这串字符里面可能有空格、制表符等空白字符，
如果直接用%s是不可以的，于是有些人就想到用gets(),当然这也是一种选择，
但是懂C的人基本上都知道gets()是一个很危险的函数，而且很难控制，
特别是与scanf()交替使用时前者的劣势更是一览无余，所以gets()一般是不推荐用的，
其实用%[^/n]就可以很好的解决这个问题了，
^表示"非"，即读入其后面的字符就结束读入。
这样想读入一行字符串直接用scanf("%[^/n]%*c",str);就可以了，
%*c的作用是读入/n,否则后面读入的将一直是/n。
所有对%s起作用的控制都可以用%[],
比如%[0-9]表示只读入'0'到'9'之间的字符，%[a-zA-Z]表示只读入字母，
'-'是范围连接符，
当然也可以直接列出你需要读入的字符，上面读字母之所以用范围连接符是因为
要输入52个字符太麻烦了，
如果你只需要读"abc"里面的字符就可以用%[abc] (或者%[cab]、%[acb]、%[a-c]、%[c-a].....),
如果想读入某个范围之外的字符串就在前面加一个'^',如：%[^a-z]就表示读入小写字母之外的字符
上面这些用法其实可以有很多推广用法的，比如说你要处理下面的字符串
23 44r f30
88888,3245;34:123.
让你输出里面所有的数字，就可以用下面的代码：
#include <stdio.h>
bool skip(){
    scanf("%*[^0-9]");
    return true;
}
int main(){
    int n;
    while (skip() && scanf("%d", &n)!=EOF)
        printf("%d/n", n);
    return 0;
}
